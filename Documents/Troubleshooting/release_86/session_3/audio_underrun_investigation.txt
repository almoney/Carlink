AUDIO UNDERRUN INVESTIGATION
============================

PROBLEM STATEMENT
-----------------
Session 3 accumulated 10,000+ audio underruns over 19 minutes of playback, leading to audio distortion and eventual ANR crash.


UNDERRUN PROGRESSION
--------------------
Time         Total Underruns    Delta    Notes
10:35:05     1                  -        First underrun (startup)
10:56:40     1                  -        After restart, first underrun
11:11:15     8,635              -        Underruns climbing
11:11:22     8,715              80       80 underruns in 7 seconds
11:14:00     10,274             1559     1559 underruns in 2.6 minutes
11:14:03     10,307             33       Still climbing

Rate at 11:14: approximately 10 underruns per second


ALSA LAYER BEHAVIOR
-------------------
When underruns occur, the ALSA hardware abstraction layer logs:
AHAL_StreamAlsa: transfer: sink 0 incomplete data sent, dropping 240 frames

240 frames at 48kHz = 5ms of audio dropped per occurrence
Drops occurring every 95ms on average
This causes audible clicks/distortion


AFFECTED COMPONENT
------------------
File: DualStreamAudioManager.kt
Class: DualStreamAudioManager
Thread: AudioPlaybackThread (THREAD_PRIORITY_URGENT_AUDIO)

The playback thread reads from ring buffers and writes to AudioTrack.
When ring buffer is empty, AudioTrack starves and reports underrun.


RING BUFFER CONFIGURATION
-------------------------
Media stream: 500ms buffer (AudioRingBuffer.forMedia())
Navigation: 200ms buffer
Voice/Call: 250ms buffer

500ms buffer should absorb USB jitter of 500-1200ms.
However, if USB read thread is blocked, buffers will drain.


SUSPECTED CAUSE
---------------
1. USB read thread on Dart side may be blocked or slow
2. MethodChannel calls from Dart to Kotlin may be serialized on main thread
3. Main thread congestion preventing audio data from reaching ring buffers

Evidence: ANR occurs when underruns are high, suggesting main thread involvement.


DATA FLOW PATH
--------------
USB Adapter
    |
    v
Dart USB Read Loop (isolate?)
    |
    v
Flutter MethodChannel (onReadingLoopMessage)
    |
    v
Kotlin Platform Handler (main thread?)
    |
    v
AudioHandler.writeAudio()
    |
    v
DualStreamAudioManager.write()
    |
    v
AudioRingBuffer (lock-free)
    |
    v
AudioPlaybackThread reads buffer
    |
    v
AudioTrack.write()
    |
    v
ALSA Hardware


INVESTIGATION NEEDED
--------------------
1. Confirm MethodChannel callbacks execute on main thread
2. Check if writeAudio blocks on ring buffer full condition
3. Verify USB read loop is in separate isolate
4. Profile time spent in each stage of data flow

5. Add logging:
   - Log ring buffer fill level when writing
   - Log time between USB read and AudioTrack write
   - Log when ring buffer write blocks


POTENTIAL FIXES
---------------

Option A: Dedicate Handler for Audio
- Create Handler with Looper on URGENT_AUDIO thread
- Post all writeAudio calls to this handler
- Removes main thread from audio path

Option B: Use Dart Isolate for USB
- Move USB read loop to dedicated isolate
- Send audio data via SendPort
- Removes Flutter engine from audio path

Option C: Native Audio Bridge
- Implement audio path entirely in Kotlin
- USB read in Kotlin worker thread
- Direct write to ring buffer
- No Dart/Flutter involvement for audio data


TEMPORARY MITIGATION
--------------------
Add to DualStreamAudioManager:

private var consecutiveUnderruns = 0
private val UNDERRUN_THRESHOLD = 100

In playback thread loop:
if (bytesRead == 0) {
    consecutiveUnderruns++
    if (consecutiveUnderruns > UNDERRUN_THRESHOLD) {
        log("Underrun threshold exceeded, reinitializing")
        reinitializeTrack(streamType)
        consecutiveUnderruns = 0
    }
} else {
    consecutiveUnderruns = 0
}

This prevents runaway accumulation by resetting the AudioTrack.
